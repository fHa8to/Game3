#include "Player.h"
#include "DxLib.h"
#include "Enemy.h"
#include "Pad.h"
#include <cmath>
#include <iostream>
#include <memory>
#include <array>

namespace
{
	//モデルのファイル名
	const char* const kModelFilename = "data/model/Knight.mv1";



	//アニメーション番号
	constexpr int kIdleAnimIndex = 1;
	constexpr int kWalkAnimIndex = 2;
	constexpr int kRunAnimIndex = 7;
	constexpr int kAttackAnimIndex = 21;
	constexpr int kAnimIndex = 3;

	//移動量
	constexpr float kSpped = 15.0f;

	//初期座標
	constexpr float kPosX = 40.0f;
	constexpr float kPosY = -8000.0f;

	//モデルのサイズ変更
	constexpr float kExpansion = 100.0f;


	//アニメーションの切り替えにかかるフレーム数
	constexpr float kAnimChangeFrame = 8.0f;
	constexpr float kAnimChangeRateSpeed = 1.0f / kAnimChangeFrame;

	//アナログスティックによる移動関連
	constexpr float kMaxSpeed = 0.1f;		//プレイヤーの最大移動速度
	constexpr float kAnalogRaneMin = 0.1f;	//アナログスティックの入力判定範囲
	constexpr float kAnalogRaneMax = 0.8f;
	constexpr float kAnglogInputMax = 1000.0f;	//アナログスティックの入力されるベクトルに

}

Player::Player():
	modelHandle(-1),
	m_currentAnimNo(-1),
	m_prevAnimNo(-1),
	m_animBlendRate(0.0f),
	angle(0.0f),
	m_cameraAngle(0.0f)
{
	//3Dモデルの読み込み
	modelHandle = MV1LoadModel(kModelFilename);
}

Player::~Player()
{
}

void Player::Init()
{	

	MV1SetScale(modelHandle, VGet(kExpansion, kExpansion, kExpansion));

	m_currentAnimNo = MV1AttachAnim(modelHandle, kIdleAnimIndex, -1, false);
	m_prevAnimNo - 1;
	m_animBlendRate = 1.0f;

	//プレイヤーの初期位置設定
	m_pos = VGet(kPosX, kPosY, 0.0f);
	m_attackPos = VAdd(m_pos, VGet(0.0f, 7.0f, 4.0f));


}

void Player::Update(VECTOR cameraPos)
{
	//アニメーションの切り替え
	if (m_prevAnimNo != -1)
	{
		m_animBlendRate += kAnimChangeRateSpeed;
		if (m_animBlendRate >= 1.0f)	m_animBlendRate = 1.0f;
		//変更前のアニメーション100%
		MV1SetAttachAnimBlendRate(modelHandle, m_prevAnimNo, 1.0f - m_animBlendRate);
		//変更後のアニメーション0%
		MV1SetAttachAnimBlendRate(modelHandle, m_currentAnimNo, m_animBlendRate);

	}



	//アニメーションを進める
	bool isLoop = UpdateAnim(m_currentAnimNo);
	UpdateAnim(m_prevAnimNo);
	if (Pad::IsPress(PAD_INPUT_RIGHT))
	{
		m_state = kMove;
		m_direction = kDown;
		m_pos = VAdd(m_pos, VGet(0.0f,
			0.0f,
			-kSpped));


	}
	if (Pad::IsRelase(PAD_INPUT_RIGHT))
	{
		m_state = kWait;
	}

	//移動
	if (Pad::IsPress(PAD_INPUT_LEFT))
	{
		m_state = kMove;
		m_direction = kUp;
		m_pos = VAdd(m_pos, VGet(0.0f,
			0.0f,
			kSpped));


	}
	if (Pad::IsRelase(PAD_INPUT_LEFT))
	{
		m_state = kWait;
	}

	//移動
	if (Pad::IsPress(PAD_INPUT_UP))
	{
		m_state = kMove;
		m_direction = kRight;
		m_pos = VAdd(m_pos, VGet(kSpped,
			0.0f,
			0.0f));


	}
	if (Pad::IsRelase(PAD_INPUT_UP))
	{
		m_state = kWait;
	}

	//移動
	if (Pad::IsPress(PAD_INPUT_DOWN))
	{
		m_state = kMove;
		m_direction = kLeft;
		m_pos = VAdd(m_pos, VGet(-kSpped,
			0.0f,
			0.0f));


	}
	if (Pad::IsRelase(PAD_INPUT_DOWN))
	{
		m_state = kWait;
	}

	if (Pad::IsPress(PAD_INPUT_2))
	{

	}

	if (!m_isAttack)
	{

		if (Pad::IsTrigger PAD_INPUT_1)
		{
			m_isAttack = true;
			ChangeAnim(kAttackAnimIndex);

		}
		else
		{
			//攻撃アニメーションが終了したら待機アニメーションを再生する
			if (isLoop)
			{

				m_isAttack = false;
				ChangeAnim(kIdleAnimIndex);
			}
		}

	}
	// ３Dモデルのポジション設定
	MV1SetPosition(modelHandle, m_pos);
	MV1SetRotationXYZ(modelHandle, VGet(0, angle, 0));
	
}

void Player::Draw()
{
	// ３Ｄモデルの描画
	MV1DrawModel(modelHandle);

}


bool Player::UpdateAnim(int attachNo)
{
	//アニメーションが設定されていないので終了
	if (attachNo == -1) return false;

	//アニメーションを進行させる
	float now = MV1GetAttachAnimTime(modelHandle, attachNo);	//現在の再生カウントを取得
	now += 0.5f;	//アニメーション進める

	//現在再生中のアニメーションの総カウントを取得
	float total = MV1GetAttachAnimTotalTime(modelHandle, attachNo);
	bool isLoop = false;
	if (now >= total)
	{
		now -= total;
		isLoop = true;
	}

	//進めた時間の設定
	MV1SetAttachAnimTime(modelHandle, attachNo, now);

	return isLoop;
}

void Player::ChangeAnim(int animIndex)
{
	//さらに古いアニメーションがアタッチされている場合はこの時点で削除しておく
	if (m_prevAnimNo != -1)
	{
		MV1DetachAnim(modelHandle, m_prevAnimNo);
	}

	//現在再生中の待機アニメーションは変更前のアニメーション扱いに
	m_prevAnimNo = m_currentAnimNo;

	//変更後のアニメーションとして攻撃アニメーションを改めて設定する
	m_currentAnimNo = MV1AttachAnim(modelHandle, animIndex, -1, false);

	//切り替えの瞬間は変更後のアニメーションが再生される
	m_animBlendRate = 0.0f;

	//変更前のアニメーション100%
	MV1SetAttachAnimBlendRate(modelHandle, m_prevAnimNo, 1.0f - m_animBlendRate);
	//変更後のアニメーション0%
	MV1SetAttachAnimBlendRate(modelHandle, m_currentAnimNo, m_animBlendRate);
}
